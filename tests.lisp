(in-package "ACL2")
(program)
(include-book "proof-checker")

;;; GOOD PROOFS ;;;

; BASIC TESTS
(defun rules1 ()
  '((=refl (= x x))
    (=symm (implies (= x y) (= y x)))
    (=trans (implies (and (= x y) (= y z)) (= x z)))
    (fcong (implies (= x y) (= (f x) (f y))))
    (gcong (implies (and (= x y) (= z w)) (= (g x z) (g y w))))))
(defun assumptions1 ()
  '((assumption1 (= a b))
    (assumption2 (= b c))))
(defun proof1 ()
  '((step1 (= a c) nil nil)
    (step2 (= (f a) (f c)) nil nil)
    (step3 (= b a) nil nil)
    (step4 (= (g (f a) b) (g (f c) a)) nil nil)))
(defun prove1 ()
  (proof-check (assumptions1) (rules1) (proof1) nil))

(defun rules2 ()
  '((times0 (implies (= y 0) (= (* x y) 0)))
    (sub-self (implies (= x y) (= (- x y) 0)))
    (=symm (implies (= x y) (= y x)))
    (=refl (= x x))))
(defun proof2 ()
  '((step1 (= b b) nil nil)
    (step2 (= (- b b) 0) nil nil)
    (step3 (= (* a (- b b)) 0) nil nil)))
(defun prove2 ()
  (proof-check nil (rules2) (proof2) nil))

(defun rules3 ()
  '((rule1 (= (f) (g)))))
(defun proof3 ()
  '((step1 (= (f) (g)) nil nil)))
(defun prove3 ()
  (proof-check nil (rules3) (proof3) nil))

; Only substitute variables, not function names
(defun rules4 ()
  '((test (a a a))))
(defun proof4 ()
  '((step1 (a b b) test nil)))
(defun prove4 ()
  (proof-check nil (rules4) (proof4) nil))

; GRAMMAR TESTS

; Basic grammar: balanced brackets
(defun assumptions5 ()
  '((base (isBal))))
(defun rules5 ()
  '((surround (implies (isBal x) (isBal [ x ])) (x y))
    (append (implies (and (isBal x) (isBal y)) (isBal x y)) (x y))))
(defun proof5 ()
  '((step1 (isBal [ ]) nil nil)
    (step2 (isBal [ ] [ ]) nil nil)
    (step3 (isBal [ [ ] [ ] ]) nil nil)
    (step4 (isBal [ [ [ ] [ ] ] ]) nil nil)))
(defun prove5 ()
  (proof-check (assumptions5) (rules5) (proof5) '([ ])))

(defun assumptions5b ()
  '((base (-*> B B))
    (eps (-> B))
    (surround (-> B [ B ]))
    (append (-> B B B))))
(defun rules5b ()
  '((prod (implies (and (-*> nonterm s1 B s2) (-> B rep)) (-*> nonterm s1 rep s2)) (s1 rep s2)))) ; Also need to constrain nonterm to refer to exactly one term
(defun proof5b ()
  '((1 (-*> B [ B ]) nil nil)
    (2 (-*> B [ [ B ] ]) nil nil)
    (3 (-*> B [ [ B B ] ]) nil nil)
    (4 (-*> B [ [ [ B ] B ] ]) nil nil)
    (5 (-*> B [ [ [ B ] [ B ] ] ]) nil nil)
    (6 (-*> B [ [ [ ] [ B ] ] ]) nil nil)
    (7 (-*> B [ [ [ ] [ ] ] ]) nil nil)))
(defun prove5b ()
  (proof-check (assumptions5b) (rules5b) (proof5b) '(B [ ])))

(defun rules6 ()
  '((s1 (implies (and (isT t1) (isU u1)) (isS x t1 u1)) (t1 u1))
    (s2 (implies (isX x1) (isS l x1)) (x1))
    (s3 (implies (isX x1) (isS x1)) (x1))
    (t1 (isT c))
    (t2 (isT l))
    (x1 (implies (isX x1) (isX x x1)) (x1))
    (x2 (implies (isU u1) (isX u1)) (u1))
    (u1 (implies (isY y1) (isU i y1)) (y1))
    (u2 (implies (isI i1) (isU v i1)) (i1))
    (u3 (implies (isI i1) (isU i1)) (i1))
    (y1 (isY x))
    (y2 (isY v))
    (i1 (implies (isI i1) (isI i i1)) (i1))
    (i2 (isI))))
(defun proof6 ()
  '((step1 (isT l) nil nil)
    (step2 (isI) nil nil)
    (step3 (isI i) nil nil)
    (step4 (isI i i) nil nil)
    (step5 (isU v i i) nil nil)
    (step6 (isS x l v i i) nil nil)))
(defun prove6 ()
  (proof-check nil (rules6) (proof6) '(c l x v i)))

(defun assumptions6b ()
  '((baseS (-*> S S))
    (s1 (-> S _x T U))
    (s2 (-> S _l X))
    (s3 (-> S X))
    (t1 (-> T _c))
    (t2 (-> T _l))
    (x1 (-> X _x X))
    (x2 (-> X _x U))
    (u1 (-> U _i Y))
    (u2 (-> U _v I))
    (u3 (-> U I))
    (y1 (-> Y _x))
    (y2 (-> Y _v))
    (i1 (-> I _i I))
    (i2 (-> I))))
(defun rules6b ()
  '((prod (implies (and (-*> nonterm s1 lhs s2) (-> lhs rep)) (-*> nonterm s1 rep s2)) (s1 rep s2))))
(defun proof6b ()
  '((1 (-*> S _x T U) nil nil)
    (2 (-*> S _x _l U) nil nil)
    (3 (-*> S _x _l _v I) nil nil)
    (4 (-*> S _x _l _v _i I) nil nil)
    (5 (-*> S _x _l _v _i _i I) nil nil)
    (6 (-*> S _x _l _v _i _i) nil nil)))
(defun prove6b ()
  (proof-check (assumptions6b) (rules6b) (proof6b) '(S T X U Y I _x _l _c _v _i)))

; Context-sensitive grammars
(defun assumptions7 ()
  '((baseS (-*> S S))
    (prod1 (-> S - _a S B C))
    (prod2 (-> S - _a B C))
    (prod3 (-> C B - H B))
    (prod4 (-> H B - H C))
    (prod5 (-> H C - B C))
    (prod6 (-> _a B - _a _b))
    (prod7 (-> _b B - _b _b))
    (prod8 (-> _b C - _b _c))
    (prod9 (-> _c C - _c _c))))
(defun rules7 ()
  '((prod (implies (and (-*> nonterm s1 lhs s2) (-> lhs - rep)) (-*> nonterm s1 rep s2)) (s1 lhs rep s2))))
(defun proof7 ()
  '((01 (-*> S _a S B C) nil nil)
    (02 (-*> S _a _a S B C B C) nil nil)
    (03 (-*> S _a _a _a B C B C B C) nil nil)
    (04 (-*> S _a _a _a B H B C B C) nil nil)
    (05 (-*> S _a _a _a B H C C B C) nil nil)
    (06 (-*> S _a _a _a B B C C B C) nil nil)
    (07 (-*> S _a _a _a B B C H B C) nil nil)
    (08 (-*> S _a _a _a B B C H C C) nil nil)
    (09 (-*> S _a _a _a B B C B C C) nil nil)
    (10 (-*> S _a _a _a B B H B C C) nil nil)
    (11 (-*> S _a _a _a B B H C C C) nil nil)
    (12 (-*> S _a _a _a B B B C C C) nil nil)
    (13 (-*> S _a _a _a _b B B C C C) nil nil)
    (14 (-*> S _a _a _a _b _b B C C C) nil nil)
    (15 (-*> S _a _a _a _b _b _b C C C) nil nil)
    (16 (-*> S _a _a _a _b _b _b _c C C) nil nil)
    (17 (-*> S _a _a _a _b _b _b _c _c C) nil nil)
    (18 (-*> S _a _a _a _b _b _b _c _c _c) nil nil)))
(defun prove7 ()
  (proof-check (assumptions7) (rules7) (proof7) '(S B C H _a _b _c -)))

(defun assumptions8 ()
  '((baseS (-*> S S))
    (s1 (-> S - _a A S))
    (s2 (-> S - _b B S))
    (s3 (-> S - T))
    (aa (-> A _a - _a A))
    (ba (-> B _a - _a B))
    (ab (-> A _b - _b A))
    (bb (-> B _b - _b B))
    (bt (-> B T - T _b))
    (at (-> A T - T _a))
    (t (-> T -))))
(defun rules8 ()
  '((prod (implies (and (-*> nonterm s1 lhs s2) (-> lhs - rep)) (-*> nonterm s1 rep s2)) (s1 lhs rep s2))))
(defun proof8 ()
  '((1 (-*> S _a A S) nil nil)
    (2 (-*> S _a A _b B S) nil nil)
    (3 (-*> S _a A _b B T) nil nil)
    (4 (-*> S _a _b A B T) nil nil)
    (5 (-*> S _a _b A T _b) nil nil)
    (6 (-*> S _a _b T _a _b) nil nil)
    (7 (-*> S _a _b _a _b) nil nil)))
(defun prove8 ()
  (proof-check (assumptions8) (rules8) (proof8) '(S A B T _a _b -)))

(defun rules9 ()
  '((num (= (* a 0) 0) nil ((a number)))
    (str (isString b) nil ((b string)))))
(defun proof9 ()
  '((1 (= (* 5 0) 0) nil nil)
    (2 (isString "abc") nil nil)))
(defun prove9 ()
  (proof-check nil (rules9) (proof9) nil))

; COOL
(defun assumptions10 ()
  '((validenv-base (isValidEnv (env)))
    (c1 (class Object))
    (c1m1 (method Object abort Object))
    (c1m2 (method Object type_name String))
;   (c1m3 (method Object copy SELF_TYPE))
    (c2 (class IO))
;   (c2m1 (method IO out_string String SELF_TYPE))
;   (c2m2 (method IO out_int Int SELF_TYPE))
    (c2m3 (method IO in_string String))
    (c2m4 (method IO in_int Int))
    (c3 (class Int))
    (c4 (class Bool))
    (c5 (class String))
    (c5m1 (method String length Int))
    (c5m2 (method String concat String String))
    (c5m3 (method String substr Int Int String))
    (sub21 (<= IO Object))
    (sub31 (<= Int Object))
    (sub41 (<= Bool Object))
    (sub51 (<= String Object))
    (lub12 (lub Object Object IO))
    (lub13 (lub Object Object Int))
    (lub14 (lub Object Object Bool))
    (lub15 (lub Object Object String))
    (lub23 (lub Object IO Int))
    (lub24 (lub Object IO Bool))
    (lub25 (lub Object IO String))
    (lub34 (lub Object Int Bool))
    (lub35 (lub Object Int String))
    (lub36 (lub Object Bool String))))
(defun rules10 ()
  '((validenv-build (implies (and (isValidEnv (env orig)) (class type)) (isValidEnv (env orig (obj id type)))) (orig))
    (symmlub (implies (and (class x) (class y) (class z) (lub x y z)) (lub x z y)))
    (selflub (implies (class x) (lub x x x)))
    (selfeql (implies (class x) (= x x)))
    (subtrans (implies (and (class a) (class b) (class c) (<= a b) (<= b c)) (<= a c)))
    (selfsub (implies (class x) (<= x x)))
    ; ... rules about actual expression constructs
    (var (implies (and (class T) (isValidEnv (env s1 (obj id T) s2))) (turns (env s1 (obj id T) s2) id hasType T)) (s1 s2))
    (assign (implies (and (isValidEnv (env s1 (obj id T) s2)) (turns (env s1 (obj id T) s2) e1 hasType T1) (class T) (class T1) (<= T1 T)) (turns (env s1 (obj id T) s2) id <- e1 hasType T1)) (s1 s2 e1))
    (true (implies (isValidEnv O) (turns O true hasType Bool)))
    (false (implies (isValidEnv O) (turns O false hasType Bool)))
    (int (implies (isValidEnv O) (turns O i hasType Int)) nil ((i number)))
    (string (implies (isValidEnv O) (turns O s hasType String)) nil ((s string)))
    (new (implies (and (isClass T) (isValidEnv O)) (turns O new T hasType T)))
    (dispatch2 (implies (and (isValidEnv O) (turns O e0 hasType T0) (turns O e1 hasType T1) (turns O e2 hasType T2) (turns O e3 hasType T3) (method T0 f T1p T2p T3p) (<= T1 T1p) (<= T2 T2p) (<= T3 T3p) (= T3 T3p)) (turns O e0 dot f op e1 comma e2 cp hasType T3)) (e0 e1 e2 e3))
    (if (implies (and (isValidEnv O) (turns O e1 hasType Bool) (turns O e2 hasType T2) (turns O e3 hasType T3) (lub T T2 T3)) (turns O if e1 then e2 else e3 fi hasType T)) (e1 e2 e3))
    (let-init (implies (and (isValidEnv (env s)) (= T0p T0) (turns (env s) e1 hasType T1) (<= T1 T0p) (turns (env s (obj x T0p)) e2 hasType T2)) (turns (env s) let x colon T0 <- e1 in e2 hasType T2)) (s e1 e2))
    (plus (implies (and (isValidEnv O) (turns O e1 hasType Int) (turns O e2 hasType Int)) (turns O e1 + e2 hasType Int)))))
(defun proof10 ()
  '((pre1 (= String String) nil nil)
    (pre2 (<= String String) nil nil)
    (pre3 (lub Object String Int) nil nil)
    (env1 (isValidEnv (env (obj y Int))) nil nil)
    (env2 (isValidEnv (env (obj y Int) (obj x String))) nil nil)
    (1 (turns (env (obj y Int)) "blah" hasType String) nil nil)
    (2 (turns (env (obj y Int) (obj x String)) true hasType Bool) nil nil)
    (3 (turns (env (obj y Int) (obj x String)) x hasType String) var nil)
    (4 (turns (env (obj y Int) (obj x String)) 4 hasType Int) nil nil)
    (5 (turns (env (obj y Int) (obj x String)) y hasType Int) nil nil)
    (6 (turns (env (obj y Int) (obj x String)) 4 + y hasType Int) nil nil)
    (7 (turns (env (obj y Int) (obj x String)) if true then x else 4 + y fi hasType Object) nil nil)
    (8 (turns (env (obj y Int)) let x colon String <- "blah" in if true then x else 4 + y fi hasType Object) nil nil)))
(defun prove10 ()
  (proof-check (assumptions10) (rules10) (proof10) '(Object abort type_name IO in_string in_int Int Bool String length concat substr true false <- colon comma dot op cp hasType if then else fi let in +)))

(defun rules11 ()
  '((rule (list (list a b) a) (a b))))
(defun proof11 ()
  '((1 (list (list x y) x) nil nil)))
(defun prove11 ()
  (proof-check nil (rules11) (proof11) nil))

;;; BAD PROOFS ;;;

(defun badalistp ()
  '((step1 (= b b) =refl (x b))))
(defun badalist-prove ()
  (prog2$
    (cw "Running badalist-prove: should fail with bad association list.~%")
    (proof-check nil (rules2) (badalistp) nil)))

(defun badalist2p ()
  '((step1 (= b b) =refl (((x b) c)))))
(defun badalist2-prove ()
  (prog2$
    (cw "Running badalist2-prove: should fail with non-atom mapping.~%")
    (proof-check nil (rules2) (badalist2p) nil)))

(defun dupnamesa ()
  '((assump (equiv a b))
    (assump (equiv b c))))
(defun dupnamesp ()
  '((step1 (equiv x y) assump ((a x) (b y)))))
(defun dupnames-prove ()
  (prog2$
    (cw "Running dupnames-prove: should fail with duplicate names.~%")
    (proof-check (dupnamesa) nil (dupnamesp) nil)))

(defun nummapp ()
  '((pf (= b b) =refl ((1 b)))))
(defun nummap-prove ()
  (prog2$
    (cw "Running nummap-prove: should fail with mapping to number.~%")
    (proof-check nil (rules2) (nummapp) nil)))

(defun badassumplena ()
  '((assump = a b)))
(defun badassumplena-prove ()
  (prog2$
    (cw "Running badassumplena-prove: should fail with bad length.~%")
    (proof-check (badassumplena) (rules2) (proof2) nil)))

(defun badassumpstmta ()
  '((assump ((= a b)))))
(defun badassumpstmt-prove ()
  (prog2$
    (cw "Running badassumpstmt-prove: should fail with malformed expression.~%")
    (proof-check (badassumpstmta) (rules2) (proof2) nil)))

(defun defconstr ()
  '((withconst (= x x))))
(defun defconstp ()
  '((step1 (= y y) withconst ((x y)))))
(defun defconst-prove ()
  (prog2$
    (cw "Running defconst-prove: should fail with forbidden name error.~%")
    (proof-check nil (defconstr) (defconstp) '(x))))

(defun atomkeyr ()
  '(((rule name) (= x x))))
(defun atomkeyp ()
  '((1 (= y y) (rule name) ((x y)))))
(defun atomkey-prove ()
  (prog2$
    (cw "Running atomkey-prove: should fail with non-atom key errors in both rule and proof.~%")
    (proof-check nil (atomkeyr) (atomkeyp) nil)))

(defun missingassumpp ()
  '((1 (= a b) =symm nil)))
(defun missingassump-prove ()
  (prog2$
    (cw "Running missingassump-prove: should fail to prove step 1.~%")
    (proof-check nil (rules1) (missingassumpp) nil)))

(defun badstrvarsr ()
  '((badrule (= x 0) (0))))
(defun badstrvars-prove ()
  (prog2$
    (cw "Running badstrvars-prove: should say str-vars contains constants.~%")
    (proof-check nil (badstrvarsr) nil nil)))

(defun badstrvars2r ()
  '((badrule (= x 0) (a (b c)))))
(defun badstrvars2-prove ()
  (prog2$
    (cw "Running badstrvars2-prove: should say str-vars contains constants.~%")
    (proof-check nil (badstrvars2r) nil nil)))

(defun nomatchp ()
  '((1 (-*> B [ x_b) prod nil)))
(defun nomatch-prove ()
  (prog2$
    (cw "Running nomatch-prove: should fail to prove step 1.~%")
    (proof-check (assumptions5b) (rules5b) (nomatchp) '(B [ ] x_b))))

(defun nomatch2p ()
  '((1 (-*> B [ x_b ] ]) prod nil)))
(defun nomatch2-prove ()
  (prog2$
    (cw "Running nomatch2-prove: should fail to prove step 1.~%")
    (proof-check (assumptions5b) (rules5b) (nomatch2p) '(B [ ] x_b))))

(defun nomatch3p ()
  '((1 (-*> B [ x_b x_b ]) prod nil)))
(defun nomatch3-prove ()
  (prog2$
    (cw "Running nomatch3-prove: should fail to prove step 1.~%")
    (proof-check (assumptions5b) (rules5b) (nomatch3p) '(B [ ] x_b))))

(defun badsublenr ()
  '((rule (f x))))
(defun badsublenp ()
  '((1 (f) rule ((x)))))
(defun badsublen-prove ()
  (prog2$
    (cw "Running badsublen-prove: should report bad substitution.~%")
    (proof-check nil (badsublenr) (badsublenp) nil)))

(defun badsublen2p ()
  '((1 (f a b) rule ((x a b)))))
(defun badsublen2-prove ()
  (prog2$
    (cw "Running badsublen2-prove: should report bad substitution.~%")
    (proof-check nil (badsublenr) (badsublen2p) nil)))

(defun badmatchlenp ()
  '((1 (f) rule nil)))
(defun badmatchlen-prove ()
  (prog2$
    (cw "Running badmatchlen-prove: should fail to prove step 1.~%")
    (proof-check nil (badsublenr) (badmatchlenp) nil)))

(defun badmatchlen2p ()
  '((1 (f a b) rule nil)))
(defun badmatchlen2-prove ()
  (prog2$
    (cw "Running badmatchlen2-prove: should fail to prove step 1.~%")
    (proof-check nil (badsublenr) (badmatchlen2p) nil)))

(defun badsubsp ()
  '((1 (= a a) =refl ((x b) (x a)))))
(defun badsubs-prove ()
  (prog2$
    (cw "Running badsubs-prove: should report bad substitutions (not just proof failure!).~%")
    (proof-check nil (rules1) (badsubsp) nil)))

(defun nosamematchp ()
  '((1 (= a b) =refl nil)))
(defun nosamematch-prove ()
  (prog2$
    (cw "Running nosamematch-prove: should fail to prove step 1.~%")
    (proof-check nil (rules1) (nosamematchp) nil)))

(defun notanumberp ()
  '((1 (= (* a 0) 0) nil nil)))
(defun notanumber-prove ()
  (prog2$
    (cw "Running notanumber-prove: should say a is not a number.~%")
    (proof-check nil (rules9) (notanumberp) nil)))

(defun notastringp ()
  '((1 (isString xyz) nil nil)))
(defun notastring-prove ()
  (prog2$
    (cw "Running notastring-prove: should say xyz is not a string.~%")
    (proof-check nil (rules9) (notastringp) nil)))

; Run all good tests
(defun check-good ()
  (cond ((not (prove1)) (prog2$ (cw "~%ERROR: Proof 1 failed.~%") nil))
        ((not (prove2)) (prog2$ (cw "~%ERROR: Proof 2 failed.~%") nil))
        ((not (prove3)) (prog2$ (cw "~%ERROR: Proof 3 failed.~%") nil))
        ((not (prove4)) (prog2$ (cw "~%ERROR: Proof 4 failed.~%") nil))
        ((not (prove5)) (prog2$ (cw "~%ERROR: Proof 5 failed.~%") nil))
        ((not (prove5b)) (prog2$ (cw "~%ERROR: Proof 5b failed.~%") nil))
        ((not (prove6)) (prog2$ (cw "~%ERROR: Proof 6 failed.~%") nil))
        ((not (prove6b)) (prog2$ (cw "~%ERROR: Proof 6b failed.~%") nil))
        ((not (prove7)) (prog2$ (cw "~%ERROR: Proof 7 failed.~%") nil))
        ((not (prove8)) (prog2$ (cw "~%ERROR: Proof 8 failed.~%") nil))
        ((not (prove9)) (prog2$ (cw "~%ERROR: Proof 9 failed.~%") nil))
        ((not (prove10)) (prog2$ (cw "~%ERROR: Proof 10 failed.~%") nil))
        ((not (prove11)) (prog2$ (cw "~%ERROR: Proof 11 failed.~%") nil))
        (T (prog2$ (cw "~%SUCCESS: All good tests passed.~%") T))))

; Run all bad tests
(defun check-bad ()
  (cond ((badalist-prove) (prog2$ (cw "~%ERROR: badalist passed, but it should have failed.~%") nil))
        ((badalist2-prove) (prog2$ (cw "~%ERROR: badalist2 passed, but it should have failed.~%") nil))
        ((dupnames-prove) (prog2$ (cw "~%ERROR: dupnames passed, but it should have failed.~%") nil))
        ((nummap-prove) (prog2$ (cw "~%ERROR: nummap passed, but it should have failed.~%") nil))
        ((badassumplena-prove) (prog2$ (cw "~%ERROR: badassumplena passed, but it should have failed.~%") nil))
        ((badassumpstmt-prove) (prog2$ (cw "~%ERROR: badassumpstmt passed, but it should have failed.~%") nil))
        ((defconst-prove) (prog2$ (cw "~%ERROR: defconst passed, but it should have failed.~%") nil))
        ((atomkey-prove) (prog2$ (cw "~%ERROR: atomkey passed, but it should have failed.~%") nil))
        ((missingassump-prove) (prog2$ (cw "~%ERROR: missingassump passed, but it should have failed.~%") nil))
        ((badstrvars-prove) (prog2$ (cw "~%ERROR: badstrvars passed, but it should have failed.~%") nil))
        ((badstrvars2-prove) (prog2$ (cw "~%ERROR: badstrvars2 passed, but it should have failed.~%") nil))
        ((nomatch-prove) (prog2$ (cw "~%ERROR: nomatch passed, but it should have failed.~%") nil))
        ((nomatch2-prove) (prog2$ (cw "~%ERROR: nomatch2 passed, but it should have failed.~%") nil))
        ((nomatch3-prove) (prog2$ (cw "~%ERROR: nomatch3 passed, but it should have failed.~%") nil))
        ((badsublen-prove) (prog2$ (cw "~%ERROR: badsublen passed, but it should have failed.~%") nil))
        ((badsublen2-prove) (prog2$ (cw "~%ERROR: badsublen2 passed, but it should have failed.~%") nil))
        ((badmatchlen-prove) (prog2$ (cw "~%ERROR: badmatchlen passed, but it should have failed.~%") nil))
        ((badmatchlen2-prove) (prog2$ (cw "~%ERROR: badmatchlen2 passed, but it should have failed.~%") nil))
        ((badsubs-prove) (prog2$ (cw "~%ERROR: badsubs passed, but it should have failed.~%") nil))
        ((nosamematch-prove) (prog2$ (cw "~%ERROR: nosamematch passed, but it should have failed.~%") nil))
        ((notanumber-prove) (prog2$ (cw "~%ERROR: notanumber passed, but it should have failed.~%") nil))
        ((notastring-prove) (prog2$ (cw "~%ERROR: notastring passed, but it should have failed.~%") nil))
        (T (prog2$ (cw "~%SUCCESS: All bad tests failed.~%") T))))

;;; RUN ALL TESTS ;;;
(defun check-all ()
  (if (and (check-good) (check-bad))
    (prog2$ (cw "~%SUCCESS: All tests passed.~%") T)
    nil))
